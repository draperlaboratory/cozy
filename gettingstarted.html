<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Getting Started &#8212; cozy 1.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=4ae1632d" />
    <script src="_static/documentation_options.js?v=56dcb7b8"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Launching a Visualization" href="launchingavisualization.html" />
    <link rel="prev" title="Welcome to cozy’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="getting-started">
<h1>Getting Started<a class="headerlink" href="#getting-started" title="Link to this heading">¶</a></h1>
<p>On this page we will cover the architecture of cozy and how you can use
it to compare two binary programs. cozy is based on the angr symbolic
execution framework, so we support the same architectures as angr. We
will be following the null_deref example, which can be found in the
examples and test_programs folder in the cozy repository. The null_deref
source code is a very simple C program which writes the integer 42 to
some location in memory:</p>
<p><strong>Prepatched null_deref (first program being compared)</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>

<span class="n">void</span> <span class="n">my_fun</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">num</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">my_num</span><span class="p">;</span>
    <span class="n">my_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_num</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;my_num: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">my_num</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Postpatched null_deref_patched (second program being compared)</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>

<span class="n">void</span> <span class="n">my_fun</span><span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">num</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">my_num</span><span class="p">;</span>
    <span class="n">my_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_num</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;my_num: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">my_num</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let’s assume that we are compiling for x64 architecture. In this case we
are interested in comparing my_fun between the two programs. Much like angr,
cozy can be used interactively through a Python REPL or through a Python script.</p>
<section id="how-cozy-makes-comparisons">
<h2>How cozy makes comparisons<a class="headerlink" href="#how-cozy-makes-comparisons" title="Link to this heading">¶</a></h2>
<p>To make comparisons between two programs with different function
implementations, cozy uses symbolic execution. Both programs are fed
the same symbolic input, and cozy runs symbolic execution until all states
terminate. At the end of execution, we have a list of deadended (terminated)
states from the prepatched program, and a list of deadended states from the
postpatched program. Each of these states have constraints associated with
them that were collected as the program stepped through symbolic execution.</p>
<p>Suppose that we take some state A from the prepatched run, and some state
B from the postpatched run. We say that A and B are <em>compatible</em> if the
constraints associated with the A and B are jointly satisfiable. In
pseudocode syntax, this roughly means that the following is True:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">is_sat</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">constraints</span> <span class="o">&amp;</span> <span class="n">B</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
</pre></div>
</div>
<p>Recall that the input to our functions are symbolic variables, so the
set of constraints is in terms of these symbolic variables. We can think
of the constraints as creating a predicate that exactly determines the
subset of the input that leads to a specific state. Taking the conjunction
of the constraints is therefore equivalent to creating a predicate
that restricts the set of input values to the intersection of the input
set for state A and state B. If this predicate is satisfiable, then
this intersection of sets is nonempty, which means that there is at
least one concrete input that will cause the program to end in state A
in the prepatched program and state B in the postpatched program.</p>
<p>Therefore the naive approach is to compare all pairs of terminal states
from the prepatched and postpatched and check for satisfiability. cozy
makes an optimization by using memoization, so in practice compatibility
checks over most programs should be fast. cozy is also capable of generating
concrete examples, which is useful for generating test cases and
walking through program execution.</p>
</section>
<section id="example-walkthrough">
<h2>Example Walkthrough<a class="headerlink" href="#example-walkthrough" title="Link to this heading">¶</a></h2>
<p>Let’s open a Python REPL and import the required libraries:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cozy</span>
<span class="kn">from</span> <span class="nn">cozy.project</span> <span class="kn">import</span> <span class="n">Project</span>
<span class="kn">from</span> <span class="nn">cozy.directive</span> <span class="kn">import</span> <span class="n">Assume</span><span class="p">,</span> <span class="n">Assert</span>
<span class="kn">import</span> <span class="nn">claripy</span>
</pre></div>
</div>
<p>Let’s begin by creating cozy projects for the two programs given
previously. A Project is a cozy class that encapsulates a single
program:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proj_prepatched</span> <span class="o">=</span> <span class="n">Project</span><span class="p">(</span><span class="s2">&quot;null_deref&quot;</span><span class="p">)</span>
<span class="n">proj_postpatched</span> <span class="o">=</span> <span class="n">Project</span><span class="p">(</span><span class="s2">&quot;null_deref_patched&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To execute the my_fun function, angr needs to know the function signature
of the functions. This information is typically not retained in the binary,
so we need to determine that with some other method. In this case we have
the source code, so we can add the function signature quite easily:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proj_prepatched</span><span class="o">.</span><span class="n">add_prototype</span><span class="p">(</span><span class="s2">&quot;my_fun&quot;</span><span class="p">,</span> <span class="s2">&quot;void f(int *a)&quot;</span><span class="p">)</span>
<span class="n">proj_postpatched</span><span class="o">.</span><span class="n">add_prototype</span><span class="p">(</span><span class="s2">&quot;my_fun&quot;</span><span class="p">,</span> <span class="s2">&quot;void f(int *a)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We now need to create sessions from each project. A session is created
from a specific project, and represents a single run of symbolic
execution. Here we pass “my_fun” to the
<a class="reference internal" href="autoapi/cozy/project/index.html#cozy.project.Project.session" title="cozy.project.Project.session"><code class="xref py py-meth docutils literal notranslate"><span class="pre">session()</span></code></a> method, which indicates that
we are going to be running the “my_fun” function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sess_prepatched</span> <span class="o">=</span> <span class="n">proj_prepatched</span><span class="o">.</span><span class="n">session</span><span class="p">(</span><span class="s2">&quot;my_fun&quot;</span><span class="p">)</span>
<span class="n">sess_postpatched</span> <span class="o">=</span> <span class="n">proj_postpatched</span><span class="o">.</span><span class="n">session</span><span class="p">(</span><span class="s2">&quot;my_fun&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Since we will only be comparing the my_fun function, we need to create
the symbolic value to pass to the functions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">arg0</span> <span class="o">=</span> <span class="n">claripy</span><span class="o">.</span><span class="n">BVS</span><span class="p">(</span><span class="s2">&quot;num_arg&quot;</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p>The symbolic value arg0 has 64 bits because it represents a pointer
on a 64-bit architecture.</p>
<p>Alternatively we could have used the <a class="reference internal" href="autoapi/cozy/primitives/index.html#cozy.primitives.sym_ptr" title="cozy.primitives.sym_ptr"><code class="xref py py-func docutils literal notranslate"><span class="pre">cozy.primitives.sym_ptr()</span></code></a> helper
function to create the claripy symbolic variable:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">archinfo</span>
<span class="n">arg0</span> <span class="o">=</span> <span class="n">cozy</span><span class="o">.</span><span class="n">primitives</span><span class="o">.</span><span class="n">sym_ptr</span><span class="p">(</span><span class="n">archinfo</span><span class="o">.</span><span class="n">ArchAMD64</span><span class="p">,</span> <span class="s2">&quot;num_arg&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We will now constrain arg0 to be either NULL or be equal to a valid memory
address in our two sessions. Currently angr has limited support for symbolic
memory addressing, so we will malloc space for our integers then constrain
arg0 accordingly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">addr_prepatched</span> <span class="o">=</span> <span class="n">sess_prepatched</span><span class="o">.</span><span class="n">malloc</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># integers are 4 bytes on the target arch</span>
<span class="n">sess_prepatched</span><span class="o">.</span><span class="n">add_constraints</span><span class="p">((</span><span class="n">arg0</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">arg0</span> <span class="o">==</span> <span class="n">addr_prepatched</span><span class="p">))</span>
<span class="n">addr_postpatched</span> <span class="o">=</span> <span class="n">sess_postpatched</span><span class="o">.</span><span class="n">malloc</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">sess_postpatched</span><span class="o">.</span><span class="n">add_constraints</span><span class="p">((</span><span class="n">arg0</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">arg0</span> <span class="o">==</span> <span class="n">addr_postpatched</span><span class="p">))</span>
</pre></div>
</div>
<p>So before any execution we have constrained arg0 to be either NULL
(0x0) or a concrete 64-bit address returned by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">malloc()</span></code>.</p>
</section>
<section id="directives-assumes-and-asserts">
<h2>Directives - Assumes and Asserts<a class="headerlink" href="#directives-assumes-and-asserts" title="Link to this heading">¶</a></h2>
<p>cozy provides support for <em>directives</em>, which are attached to specific
program instructions. Two basic directives that you should know about
are <a class="reference internal" href="autoapi/cozy/directive/index.html#cozy.directive.Assume" title="cozy.directive.Assume"><code class="xref py py-class docutils literal notranslate"><span class="pre">cozy.directive.Assume</span></code></a> and <a class="reference internal" href="autoapi/cozy/directive/index.html#cozy.directive.Assert" title="cozy.directive.Assert"><code class="xref py py-class docutils literal notranslate"><span class="pre">cozy.directive.Assert</span></code></a>.
Assume and assert function by pausing execution once a specific instruction
is reached and adding constraints to the SMT solver. Assumes are used for
adding preconditions, and are often set to be triggered at the start of
functions. Asserts are triggered if there exists an input that will cause
the assert to evaluate to false. Note that directives do not change the
code being executed: they work more or less in the same way as debug
breakpoints.</p>
<p>To demonstrate that a null dereference can occur in the prepatched binary
and not in the postpatched binary, let’s add asserts to specific addresses.
Running the binaries through a tool like Ghidra reveals that the NULL
dereference occurs at an offset of 0x10 from the start of my_fun in the
prepatched binary. At this point the address being dereferenced is stored
in the RAX register. Let’s create a directive that encodes these observations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mem_write_okay_prepatched</span> <span class="o">=</span> <span class="n">Assert</span><span class="o">.</span><span class="n">from_fun_offset</span><span class="p">(</span>
        <span class="n">project</span><span class="o">=</span><span class="n">proj_prepatched</span><span class="p">,</span>
        <span class="n">fun_name</span><span class="o">=</span><span class="s2">&quot;my_fun&quot;</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="mh">0x10</span><span class="p">,</span>
        <span class="n">condition_fun</span><span class="o">=</span><span class="k">lambda</span> <span class="n">state</span><span class="p">:</span> <span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rax</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">,</span>
        <span class="n">info_str</span><span class="o">=</span><span class="s2">&quot;Dereferencing null pointer&quot;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>When execution reaches my_fun+0x10, the evaluation will be halted and
cozy will pass the angr.SimState to the condition_fun and will check to see
if it is possible to find an input value that will trigger the condition.
Let’s add the directive to the prepatch session:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sess_prepatched</span><span class="o">.</span><span class="n">add_directives</span><span class="p">(</span><span class="n">mem_write_okay_prepatched</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s invoke the prepatched my_fun with arg0 as the symbolic input via the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">run_result</span> <span class="o">=</span> <span class="n">sess_prepatched</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">arg0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">run_result</span><span class="p">)</span>
</pre></div>
</div>
<p>Which prints the following result that informs us that an assertion was triggered:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RunResult</span><span class="p">(</span><span class="mi">1</span> <span class="n">deadended</span><span class="p">,</span> <span class="mi">0</span> <span class="n">errored</span><span class="p">,</span> <span class="mi">1</span> <span class="n">asserts_failed</span><span class="p">,</span> <span class="mi">0</span> <span class="n">assume_warnings</span><span class="p">,</span> <span class="mi">0</span> <span class="n">postconditions_failed</span><span class="p">,</span> <span class="mi">0</span> <span class="n">spinning</span><span class="p">)</span>
</pre></div>
</div>
<p>To view a report on what went wrong with the assertion, let’s create
a report using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">report_asserts_failed()</span></code>
method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">run_result</span><span class="o">.</span><span class="n">report</span><span class="p">([</span><span class="n">arg0</span><span class="p">]))</span>
</pre></div>
</div>
<p>Which prints off the human-readable report:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Errored</span> <span class="n">Report</span><span class="p">:</span>
<span class="n">No</span> <span class="n">errored</span> <span class="n">states</span>

<span class="n">Asserts</span> <span class="n">Failed</span> <span class="n">Report</span><span class="p">:</span>
<span class="n">Assert</span> <span class="k">for</span> <span class="n">address</span> <span class="mh">0x401179</span> <span class="n">was</span> <span class="n">triggered</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">Bool</span> <span class="n">int_arg_0_64</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="o">&gt;</span>
<span class="n">Dereferencing</span> <span class="n">null</span> <span class="n">pointer</span>
<span class="n">Here</span> <span class="n">are</span> <span class="mi">1</span> <span class="n">concrete</span> <span class="nb">input</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">this</span> <span class="n">particular</span> <span class="n">assertion</span><span class="p">:</span>
<span class="mf">1.</span>
    <span class="p">[</span><span class="o">&lt;</span><span class="n">BV64</span> <span class="mh">0x0</span><span class="o">&gt;</span><span class="p">]</span>

<span class="n">Postconditions</span> <span class="n">Failed</span> <span class="n">Report</span><span class="p">:</span>
<span class="n">No</span> <span class="n">postcondition</span> <span class="n">failure</span> <span class="n">triggered</span>

<span class="n">Spinning</span> <span class="p">(</span><span class="n">Looping</span><span class="p">)</span> <span class="n">States</span> <span class="n">Report</span><span class="p">:</span>
<span class="n">No</span> <span class="n">spinning</span> <span class="n">states</span> <span class="n">were</span> <span class="n">reported</span>
</pre></div>
</div>
<p>As part of the report, cozy reports that the concretized input that leads to
this assertion being triggered occurs when the input argument is 0.</p>
<p>Now let’s make another assert for the postpatched session and verify
that no NULL dereference occurs in the postpatch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mem_write_okay_postpatched</span> <span class="o">=</span> <span class="n">Assert</span><span class="o">.</span><span class="n">from_fun_offset</span><span class="p">(</span>
        <span class="n">project</span><span class="o">=</span><span class="n">proj_postpatched</span><span class="p">,</span>
        <span class="n">fun_name</span><span class="o">=</span><span class="s2">&quot;my_fun&quot;</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="mh">0x17</span><span class="p">,</span>
        <span class="n">condition_fun</span><span class="o">=</span><span class="k">lambda</span> <span class="n">state</span><span class="p">:</span> <span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rax</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">,</span>
        <span class="n">info_str</span><span class="o">=</span><span class="s2">&quot;Dereferencing null pointer&quot;</span>
    <span class="p">)</span>
<span class="n">sess_postpatched</span><span class="o">.</span><span class="n">add_directives</span><span class="p">(</span><span class="n">mem_write_okay_postpatched</span><span class="p">)</span>
<span class="n">run_result</span> <span class="o">=</span> <span class="n">sess_postpatched</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">run_result</span><span class="p">)</span>
</pre></div>
</div>
<p>In the console we see that no assertions were triggered:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RunResult</span><span class="p">(</span><span class="mi">1</span> <span class="n">deadended</span><span class="p">,</span> <span class="mi">0</span> <span class="n">errored</span><span class="p">,</span> <span class="mi">0</span> <span class="n">asserts_failed</span><span class="p">,</span> <span class="mi">0</span> <span class="n">assume_warnings</span><span class="p">,</span> <span class="mi">0</span> <span class="n">postconditions_failed</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="making-the-comparisons">
<h2>Making the Comparisons<a class="headerlink" href="#making-the-comparisons" title="Link to this heading">¶</a></h2>
<p>To compare two program executions, we need two <code class="xref py py-class docutils literal notranslate"><span class="pre">cozy.project.RunResult</span></code> objects.
Let’s create fresh sessions and re-run without any directives attached. This time we will make use of
<code class="xref py py-func docutils literal notranslate"><span class="pre">primitive.sym_ptr_constraints()</span></code> to generate the constraints instead of creating them manually:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sess_prepatched</span> <span class="o">=</span> <span class="n">proj_prepatched</span><span class="o">.</span><span class="n">session</span><span class="p">(</span><span class="s2">&quot;my_fun&quot;</span><span class="p">)</span>
<span class="n">sess_postpatched</span> <span class="o">=</span> <span class="n">proj_postpatched</span><span class="o">.</span><span class="n">session</span><span class="p">(</span><span class="s2">&quot;my_fun&quot;</span><span class="p">)</span>
<span class="n">addr_prepatched</span> <span class="o">=</span> <span class="n">sess_prepatched</span><span class="o">.</span><span class="n">malloc</span><span class="p">(</span><span class="n">cozy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">INT_SIZE</span><span class="p">)</span>
<span class="n">sess_prepatched</span><span class="o">.</span><span class="n">add_constraints</span><span class="p">(</span><span class="n">cozy</span><span class="o">.</span><span class="n">primitives</span><span class="o">.</span><span class="n">sym_ptr_constraints</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">addr_prepatched</span><span class="p">,</span> <span class="n">can_be_null</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="n">addr_postpatched</span> <span class="o">=</span> <span class="n">sess_postpatched</span><span class="o">.</span><span class="n">malloc</span><span class="p">(</span><span class="n">cozy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">INT_SIZE</span><span class="p">)</span>
<span class="n">sess_postpatched</span><span class="o">.</span><span class="n">add_constraints</span><span class="p">(</span><span class="n">cozy</span><span class="o">.</span><span class="n">primitives</span><span class="o">.</span><span class="n">sym_ptr_constraints</span><span class="p">(</span><span class="n">arg0</span><span class="p">,</span> <span class="n">addr_postpatched</span><span class="p">,</span> <span class="n">can_be_null</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<p>Now let’s run both of our new sessions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prepatched_result</span> <span class="o">=</span> <span class="n">sess_prepatched</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">arg0</span><span class="p">])</span>
<span class="n">postpatched_result</span> <span class="o">=</span> <span class="n">sess_postpatched</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">arg0</span><span class="p">])</span>
</pre></div>
</div>
<p>We can inspect the results object to see how many states we are dealing with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">prepatched_result</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">postpatched_result</span><span class="p">)</span>
</pre></div>
</div>
<p>This prints the following messages:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RunResult</span><span class="p">(</span><span class="mi">1</span> <span class="n">deadended</span><span class="p">,</span> <span class="mi">0</span> <span class="n">errored</span><span class="p">,</span> <span class="mi">0</span> <span class="n">asserts_failed</span><span class="p">,</span> <span class="mi">0</span> <span class="n">assume_warnings</span><span class="p">,</span> <span class="mi">0</span> <span class="n">postconditions_failed</span><span class="p">,</span> <span class="mi">0</span> <span class="n">spinning</span><span class="p">)</span>
<span class="n">RunResult</span><span class="p">(</span><span class="mi">2</span> <span class="n">deadended</span><span class="p">,</span> <span class="mi">0</span> <span class="n">errored</span><span class="p">,</span> <span class="mi">0</span> <span class="n">asserts_failed</span><span class="p">,</span> <span class="mi">0</span> <span class="n">assume_warnings</span><span class="p">,</span> <span class="mi">0</span> <span class="n">postconditions_failed</span><span class="p">,</span> <span class="mi">0</span> <span class="n">spinning</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now make a comparison between these two terminated results. Constructing a Comparison object is used to do
the comparison computation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">comparison_results</span> <span class="o">=</span> <span class="n">cozy</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">Comparison</span><span class="p">(</span><span class="n">prepatched_result</span><span class="p">,</span> <span class="n">postpatched_result</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>To view a human readable report, we can now call the <a class="reference internal" href="autoapi/cozy/analysis/index.html#cozy.analysis.Comparison.report" title="cozy.analysis.Comparison.report"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cozy.analysis.Comparison.report()</span></code></a> method, which
will convert the <a class="reference internal" href="autoapi/cozy/analysis/index.html#cozy.analysis.Comparison" title="cozy.analysis.Comparison"><code class="xref py py-class docutils literal notranslate"><span class="pre">Comparison</span></code></a> to a human readable summary:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">comparison_results</span><span class="o">.</span><span class="n">report</span><span class="p">([</span><span class="n">arg0</span><span class="p">]))</span>
</pre></div>
</div>
<p>We now see the human readable report</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span>STATE PAIR (0, DEADENDED_STATE), (0, DEADENDED_STATE) are different
<span class="linenos"> 2</span>Memory difference detected for 0,0:
<span class="linenos"> 3</span>{&#39;range(0x0, 0x4)&#39;: (&lt;BV32 0x2a000000&gt;, &lt;BV32 0x0&gt;)}
<span class="linenos"> 4</span>Instruction pointers for these memory writes:
<span class="linenos"> 5</span>{&#39;range(0x0, 0x4)&#39;: (frozenset({&lt;BV64 0x401179&gt;}), frozenset())}
<span class="linenos"> 6</span>Register difference detected for 0,0:
<span class="linenos"> 7</span>{&#39;eflags&#39;: (&lt;BV64 0x0&gt;, &lt;BV64 0x44&gt;), &#39;flags&#39;: (&lt;BV64 0x0&gt;, &lt;BV64 0x44&gt;), &#39;rflags&#39;: (&lt;BV64 0x0&gt;, &lt;BV64 0x44&gt;)}
<span class="linenos"> 8</span>Here are 1 concrete input(s) for this particular state pair:
<span class="linenos"> 9</span>1.
<span class="linenos">10</span>    Input arguments: [&lt;BV64 0x0&gt;]
<span class="linenos">11</span>    Concrete mem diff: {&#39;range(0x0, 0x4)&#39;: (&lt;BV32 0x2a000000&gt;, &lt;BV32 0x0&gt;)}
<span class="linenos">12</span>    Concrete reg diff: {&#39;eflags&#39;: (&lt;BV64 0x0&gt;, &lt;BV64 0x44&gt;), &#39;flags&#39;: (&lt;BV64 0x0&gt;, &lt;BV64 0x44&gt;), &#39;rflags&#39;: (&lt;BV64 0x0&gt;, &lt;BV64 0x44&gt;)}
<span class="linenos">13</span>
<span class="linenos">14</span>STATE PAIR (0, DEADENDED_STATE), (1, DEADENDED_STATE) are different
<span class="linenos">15</span>The memory was equal for this state pair
<span class="linenos">16</span>Register difference detected for 0,1:
<span class="linenos">17</span>{&#39;eflags&#39;: (&lt;BV64 0x0&gt;, &lt;BV64 0x4&gt;), &#39;flags&#39;: (&lt;BV64 0x0&gt;, &lt;BV64 0x4&gt;), &#39;rflags&#39;: (&lt;BV64 0x0&gt;, &lt;BV64 0x4&gt;)}
<span class="linenos">18</span>Here are 1 concrete input(s) for this particular state pair:
<span class="linenos">19</span>1.
<span class="linenos">20</span>    Input arguments: [&lt;BV64 0xc0000000&gt;]
<span class="linenos">21</span>    Concrete reg diff: {&#39;eflags&#39;: (&lt;BV64 0x0&gt;, &lt;BV64 0x4&gt;), &#39;flags&#39;: (&lt;BV64 0x0&gt;, &lt;BV64 0x4&gt;), &#39;rflags&#39;: (&lt;BV64 0x0&gt;, &lt;BV64 0x4&gt;)}
<span class="linenos">22</span>
<span class="linenos">23</span>There are no prepatched orphans
<span class="linenos">24</span>There are no postpatched orphans
</pre></div>
</div>
<p>We can see that cozy found a diff between the 0th deadended
(terminated) state in the prepatched program (we will refer to this
state as s0) and the 0th deadended state in the postpatched program
(we will refer to this state as s0’). Together these two states form a
state pair, which is displayed on line 1 of the report. As we will see
from the following lines of the report, s0 represents the sole final
symbolic state for the prepatched function (there is only one path
through this function), and s0’ represents the final state for the
“false” branch of the postpatched function (i.e., the path that is
triggered by a NULL argument).</p>
<p>Line 3 displays the memory addresses that are different. Contents of
memory for written ranges are mapped to a tuple containing the
symbolic bytes at those addresses as a (prepatched, postpatched)
tuple. In this case, memory at addresses 0x0 to 0x4 is 0x2a000000 in
s0 (because the prepatched function writes 0x2a = 42 to the NULL
address), and 0x0 in s0’ (because the NULL check prevents the write
from occurring).</p>
<p>Line 5 tells the instruction pointer the program was at when it wrote
to those specific memory address ranges.  Here we see that the
prepatched program was at the instruction 0x401179 when it wrote to
address 0x0, and the postpatched program never wrote to that address
(hence the empty frozenset).</p>
<p>Line 7 gives the symbolic register difference between the states. As we can see, the flags registers
are different due to the presence of a branch in the postpatched program. As with the memory, each register
maps to a (prepatched, postpatched) tuple which gives the symbolic contents of the registers.</p>
<p>Lines 8-12 gives concretized input that will cause the prepatched program to end in state s0 and
the postpatched program in state s0’. The input argument is concretized to 0x0 (aka NULL). Additionally since
the memory contents and register contents may be symbolic, we provide a concretized version of those as well.</p>
<p>Lines 14-21 tells us that there is another diff for the state pair
(0,1). The second state in this pair represents the “true” branch
through the postpatched function. In this case we observe that the
only difference is in the flags registers, and that there are no
observable differences in memory. The concrete input argument for this
pair is when the input is non-NULL.</p>
<p>The next lines describe any orphaned states - typically there will be none. An orphaned state is a state in which
there are no compatible pair states.</p>
</section>
<section id="further-examples">
<h2>Further Examples<a class="headerlink" href="#further-examples" title="Link to this heading">¶</a></h2>
<p>Further examples on how to use cozy for some simple programs can be found at <a class="reference external" href="https://github.com/draperlaboratory/cozy/tree/main/examples">https://github.com/draperlaboratory/cozy/tree/main/examples</a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">cozy</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#how-cozy-makes-comparisons">How cozy makes comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-walkthrough">Example Walkthrough</a></li>
<li class="toctree-l2"><a class="reference internal" href="#directives-assumes-and-asserts">Directives - Assumes and Asserts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#making-the-comparisons">Making the Comparisons</a></li>
<li class="toctree-l2"><a class="reference internal" href="#further-examples">Further Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="launchingavisualization.html">Launching a Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="concolic.html">Using Concolic Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="hooks.html">Dealing with Hooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="sideeffects.html">Modeling I/O Side Effects</a></li>
<li class="toctree-l1"><a class="reference internal" href="underconstrained.html">Underconstrained Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="autoapi/index.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to cozy’s documentation!</a></li>
      <li>Next: <a href="launchingavisualization.html" title="next chapter">Launching a Visualization</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, The Charles Stark Draper Laboratory.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/gettingstarted.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>